```{r create_basic_documentation, echo=TRUE}
doc <- NULL
doc$run.date <- date()
doc$version <- system(' git rev-parse HEAD', intern=TRUE)
doc$author <- "Steve Simon (KUMC)"
doc$maintainer <- "Steve Simon (KUMC)"
doc$assistants <- "Dan Connolly"
```


Case-control
============
For context, see [485].

[485]: https://informatics.gpcnetwork.org/trac/Project/ticket/485
[bc_qa]: https://bitbucket.org/gpcnetwork/bc_qa

This program reads data from PCRONET CDM and matches it
with patient numbers from i2b2 to get a case-control
data set. It stores the data and some intermediate files in
an RData file.

Here's a summary of how the data was selected. We
identified four disease groups in Heron (KUMC's i2b2).

Breast cancer (as identified in the SEER Site Summary),

All other cancers (again from SEER),

Diabetes (ICD9 250 or ICD10 E08-E13), and

Ischemic heart disease (ICD9 410-414.99 or ICD10 I20-I25).

All males were excluded.

The first group represents cases and the other three
represent different control groups. Patients who qualified
for two or more of the above groups were excluded from the
analysis.

There were no date restrictions. In future versions, we may want
to consider some date restrictions and try matching subjects on
age.

We then merged that data with the PCORNET CDM to get 
any ICD9 codes associated with each patient.

Two companion programs, analyze_lasso.Rmd and analyze_sensitivity.Rmd,
take the resulting data set and produces simple graphs and analyses. 

This program was run on `r doc$date` using version `r doc$version`.
The original author is `r doc$author`. `r doc$maintainer`
is currently maintaining and enhancing this program
with the assistance of `r doc$assistants`.


```{r run_preliminaries, echo=TRUE}

# load required libraries.

library("ROracle")
library("RSQLite")

# Backup image (just in case) and then start with a blank slate.

save.image("backup.RData")
rm(list=ls())

# Set verbose option, if TRUE, print various intermediate values and quality checks.

verbose=TRUE

# Check to see if you are in the proper subdirectory.

if (verbose) {
  cat("\n\nQuality check: Are we in the correct directory?\n")
  print(getwd())
}

# Control wrapping

options(width=90)

# Document when the program started

start_time <- Sys.time()
if (verbose) {
  cat("\n\nProgram started at ")
  print(start_time)
}
```

Here are the special functions needed for this program and brief
tests of their functionality.

```{r create_special_functions}

align_icd9_codes <- function(dx_old) {
  # This program strips out the dots and pads short
  # icd9 codes with zeros. It prints out anything
  # that is too short or too long.
  dx_new <- gsub(".","",dx_old,fixed=TRUE)
  dx_new <- ifelse(nchar(dx_new)==3,paste(dx_new,"0",sep=""),dx_new)
  dx_new <- ifelse(nchar(dx_new)==4,paste(dx_new,"0",sep=""),dx_new)
  cat("\n\nThe following diagnosis codes are invalid:\n")
  print(sort(unique(dx_new[nchar(dx_new)!=5])))
  cat(".\n")
  return(dx_new)
}

if (verbose) {
  cat("\nSimple test.\n")
  align_icd9_codes(c("0014","V28.9","XX"))
}

display_elapsed_time <- function() {
  # This program displays the elapsed time
  # and returns the current time 
  # so you can optionally reset the timer.
  # There has to be a better way to do this.
  cat("\n\nThis code chunk required ")
  print(round(Sys.time()-start_time))
  return(Sys.time())
}

list_random_rows <- function(df,n=5) {
  # select and return first five rows, last five rows, and
  # a few random rows from a data frame.
  # If input is a vector, coerce it into a data frame
  df <- data.frame(df, stringsAsFactors=FALSE)
  new_list <- NULL
  nrows <- dim(df)[1]
  if (nrows<=3*n) {return(list(All_rows=df))}
  top_name <- paste("First",n,"rows",sep="_")
  mid_name <- paste("Random",n,"rows",sep="_")
  bot_name <- paste("Last",n,"rows",sep="_")
  new_list[[top_name]] <- head(df,n)
  selected_rows <- sample((n+1):(nrows-n),n)
  new_list[[mid_name]] <- df[selected_rows, ]
  new_list[[bot_name]] <- tail(df,n)
  return(new_list)
}

print_random_rows <- function(df, n=5) {
  # explicitly prints output from list_random_rows
  print(list_random_rows(df, n))
}

if (verbose) {
  cat("\nSimple test.\n")
  print_random_rows(1:100)
  print_random_rows(c(LETTERS,letters))
}

strip_specials <- function(x0) {
  # This function strips special characters from a character vector,
  # replacing most of them with an underscore.
  x0 <- gsub(" ","_",x0,fixed=TRUE)
  x0 <- gsub("-","_",x0,fixed=TRUE)
  x0 <- gsub('"',"_", x0,fixed=TRUE)
  x0 <- gsub('/',"_", x0,fixed=TRUE)
  x0 <- gsub('+',"_", x0,fixed=TRUE)
  x0 <- gsub('&',"_", x0,fixed=TRUE)
  return(x0)
}

if (verbose) {
  cat("\nSimple test.\n")
  strip_specials(c("test one","test-two","test&three"))
}

if (verbose) start_time <- display_elapsed_time()

```

Set up storage for temporary data frames and matrices (d)
and notes for my own reference.

```{r setup_archive_storage}

# This program uses many different data frames. Data frames associated
# with different databases will typically start with the same letter.
#   p: individual patient ids for each disease group
#   i: data from additional i2b2 queries
#   c: data from the CDM
#
# Most of these are intermediate data frames.
# As a quality check and to test new code, I will store the intermediate
# data frames in a list called archive

archive <- NULL
notes <- NULL    # temporary--remove when transitioned to archive
archive$header <- "This is a list of various intermediate files."
if (verbose) start_time <- display_elapsed_time()
```

Design the appropriate sql queries.

```{r design_sql_queries}

# I need to put all my SQL queries in one spot so
# I can model one SQL query after the previous one.
# As I get better with SQL, I will move the queries
# closer to the program location where they get used.

sql <- NULL

sql[["distinct_patients"]] <-
  "select distinct patient_num
   from observation_fact"

sql[["matching_count"]] <- 
  "select distinct j.PATIENT_NUM, j.GP, p.PATID
   from pcornet_cdm.diagnosis P
   JOIN PC j
   on p.PATID = j.PATIENT_NUM
   where p.DX_TYPE = '09'"

sql[["patient_diagnoses"]] <-
  "select distinct j.PATIENT_NUM, j.GP, p.DX
   from pcornet_cdm.diagnosis P
   join PC j
   on p.PATID = j.PATIENT_NUM
   where p.DX_TYPE='09'"

sql[["observation_fact"]] <-
  "select o.patient_num, o.concept_cd c.name_char 
   from observation_fact o
   inner join (concept_dimension c
     where concept_path LIKE '\\i2b2\\Procorders%' OR
       concept_path LIKE '\\i2b2\\Procedures%')
   ON o.concept_cd=c.concept_cd"

if (verbose) {
  for (i in 1:length(sql)) {
    print(names(sql)[i])
    cat(sql[[i]])
    cat("\n\n")
  }
}

if (verbose) start_time <- display_elapsed_time()

```

This section reads in the patient ids for the various disease groups.

The file, disease_group_databases.txt, should have one entry for each file.
It also has information about which site the data 
comes from and which disease group the patients come from.

```{r get_patient_database_names, echo=TRUE}

di <- "/d1/home/ssimon/bc_qa/bc_case_control"
setwd(di)
fn <- "disease_group_databases.txt"
pa <- read.csv(file=fn, header=TRUE, stringsAsFactors=FALSE)
archive$pa_patient_identifiers_file_information <- pa

if (verbose) print(pa)

i.case <- pa$disease_group[pa$case==1]
i.control <- pa$disease_group[pa$case==0]

if (verbose) start_time <- display_elapsed_time()

```

Now loop across file names to get patient numbers for each group.

```{r get_patient_numbers}

# pb: distinct patient numbers in each disease group
pb <- NULL
for (i in 1:length(pa$file_location)) {
  p_connect <- dbConnect(SQLite(), dbname=pa$file_location[i])
  group_name <- pa$disease_group[i] 
  pb[[group_name]] <- dbGetQuery(p_connect, sql["distinct_patients"])
  dbDisconnect(p_connect)
  archive_name <- paste("pb", group_name, "patient numbers", sep="_")
  archive[[archive_name]] <- pb[[group_name]]
}

if (verbose) {
  for (i in 1:length(pb)) {
    print(names(pb)[i])
    print(dim(pb[[i]]))
    print_random_rows(pb[[i]])
  }
}

pc <- data.frame(gp=names(pb[1]), pb[[1]], stringsAsFactors=FALSE)
for (k in 2:length(pb)) {
  pc <- rbind(pc, data.frame(gp=names(pb[k]), pb[[k]], stringsAsFactors=FALSE))
}
archive$pc_stacked_patient_numbers <- pc

if (verbose) print_random_rows(pc)

if (verbose) start_time <- display_elapsed_time()

```

Next, you need to write the patient numbers to the same
location as the PCORnet CDM database.

```{r write_patient_numbers_to_cdm}

# This code borrowed from cdm_fun.Rmd.

cdm_config <- read.csv('../cdm_config.csv', stringsAsFactors=FALSE)
missing_config <- setdiff(c('account', 'password'), names(cdm_config))
stopifnot(length(missing_config) == 0)
c_connect <-
  dbConnect(Oracle(), cdm_config$account, cdm_config$password, cdm_config$access)

if (verbose) {
  cat("Simple test")
  dbGetQuery(c_connect, "select * from pcornet_cdm.diagnosis where rownum < 10")
}

names(pc) <- toupper(names(pc))
dbWriteTable(c_connect, "PC", pc, overwrite=TRUE)

if (verbose) dbListTables(c_connect)

if (verbose) start_time <- display_elapsed_time()

```

Now pull out all the diagnosis codes associated with our patient list.

```{r extract_cdm_data}

# Note: there are patients who are in the various
# disease groups, but who do not have any ICD9 codes.
# I need to investigate why.

if (verbose) {
  mc <- dbGetQuery(c_connect, sql[["matching_count"]])
  print(table(mc$GP))
  print(table(pc$GP))
} 

ca <- dbGetQuery(c_connect, sql[["patient_diagnoses"]])
archive$SQL_query_from_pcornet_cdm <- ca

if (verbose) {
  print(dim(ca))
  print_random_rows(ca)
}

if (verbose) start_time <- display_elapsed_time()

```


Now, let's allow ourselves the ability to screen out
any diagnosis codes that occur infrequently among the
cases.

```{r find_common_dx}

# Add a dx_count column that notes how often the DX appears
# among the case groups. This will allow you to select only
# the "popular" DX codes.

cb <- table(ca$DX[ca$GP==i.case])
archive$cb_cdm_diagnosis_counts_table <- cb

# Note: as.numeric is needed here because you need to strip out
# the names before merging.
# Also note that this merge statement will remove any diagnosis
# codes which occur only among the controls.

cc <- data.frame(DX=names(cb), dx_count=as.numeric(cb))
archive$cc_cdm_diagnosis_counts_data_frame <- cc

cd <- merge(ca, cc)
archive$cd_cdm_diagnoses_merged_with_counts <- cd

if (verbose) {
  print_random_rows(cc)
  print_random_rows(cd)
  print(length(unique(ca$DX)))
  print(length(unique(cd$DX)))
}

if (verbose) start_time <- display_elapsed_time()

```

While you can get the nice labels for icd9 codes from i2b2, it is easier
just to pull them from another source. I chose labels from the
[https://www.cms.gov/medicare/coding/ICD9providerdiagnosticcodes/codes.html CMS]
site. 

```{r get-nice-names, echo=TRUE}

fn <- "icd9_labels.csv"
ce <- read.csv(fn, header=TRUE, as.is=TRUE, row.names=NULL)
archive$ce_icd9_codes_and_labels <- ce

ce$nice_label <- paste(strip_specials(ce$short_label),ce$DX,sep="_")
if (verbose) print_random_rows(ce$nice_label)

# Here are diagnosis codes in cd, not found in il.

if (verbose) print_random_rows(sort(setdiff(cd$DX,ce$DX)))

cd$dx_new <- align_icd9_codes(cd$DX)
ce$dx_new <- align_icd9_codes(ce$diagnosis_code)

# Here are diagnosis codes in cd, not found in il.
if (verbose) print(sort(setdiff(cd$dx_new,ce$dx_new)))
ce$dx_label <- paste(strip_specials(ce$short_label), ce$dx_new, sep="_")
d$lb <- merge(cd, ce[, c("dx_new","dx_label")], all.x=TRUE, all.y=FALSE)
notes$lb <- "DX codes and nice labels"
if (verbose) {
  print_random_rows(d$lb)
  start_time <- display_elapsed_time()
}
```

In addition to CDM data, you can get lots of fun stuff
from i2b2 queries.

Two that I have so far are imaging variables, and procedure codes.

```{r now get i2b2 codes, echo=TRUE}


d$ia <-
  read.csv(file="i2b2_variables_databases.txt", header=TRUE, stringsAsFactors=FALSE)
notes$ia <- "i2b2 file information"
if (verbose) {
  print(d$ia)
  start_time <- display_elapsed_time()
}

of <- NULL

sql[["observation_fact"]] <-
  "select distinct patient_num, GP, concept_cd, name_char 
   from observation_fact
   inner join (
     select concept_cd AS ccd, name_char
     from concept_dimension
     where
       concept_path LIKE '\\i2b2\\Procorders%' OR
       concept_path LIKE '\\i2b2\\Procedures%'
   )
   on concept_cd=ccd
   inner join (
     select PATIENT_NUM AS pn, GP
     from PC
   )
   on patient_num = pn"

for (f in d$ia$file_location) {
  variables_conn <- dbConnect(SQLite(), dbname=f)
  of[[f]] <- dbGetQuery(variables_conn, sql[["observation_fact"]])
  if (verbose) {
    print(f)
    print_random_rows(of[[f]])
  }
}
# Since we are importing multiple i2b2 files, we need to stack these
# into a single data frame.
d$ib <- of[[1]]
notes$ib <- "Stacked data from i2b2"
for (i in 2:length(of)) {
  d$ib <- rbind(d$ib, of[[i]])
}
if (verbose) {
  print(dim(d$ib))
  print_random_rows(d$ib)
}
# Add a concept_count column that notes how often concept_cd appears
# among the case groups. This will allow you to select only
# the "popular" concept_cd codes.
d$it <- table(d$ib$concept_cd[d$ib$GP==i.case])
notes$tb <- "Frequency counts for concept_cd among the cases."
# Note: as.numeric is needed here because you need to strip out
# the names before merging.
# Also note that this merge statement will remove any diagnosis
# codes which occur only among the controls.
d$id <- data.frame(concept_cd=names(d$it), dx_count=as.numeric(d$it))
notes$id <- "Convert table into data frame"
d$im <- merge(d$ib, d$id)
notes$im <- "Merge frequency counts in with original diagnoses."
if (verbose) {
  print_random_rows(d$id)
  print_random_rows(d$im)
  print(length(unique(d$id$concept_cd)))
  print(length(unique(d$im$concept_cd)))
  start_time <- display_elapsed_time()
}

for (f in d$ia$file_location) {
  variables_conn <- dbConnect(SQLite(), dbname=f)
  dbWriteTable(variables_conn, "PC", pc, overwrite=TRUE)
  if (verbose) dbListTables(variables_conn)
}
if (verbose) start_time <- display_elapsed_time()

```

Now save everything for later use.

```{r save-everything, echo=TRUE}
save.image(file="extract_case_control.RData")
lb <- d$lb
st <- pc
save(
  lb, st, i.case, i.control,
  list_random_rows, print_random_rows,
  file="case_control_data.RData")
if (verbose) {
  start_time <- display_elapsed_time()
  cat("\n\nProgram ended at")
  print(Sys.time())
}
```
