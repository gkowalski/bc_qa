```{r create-basic-documentation, echo=TRUE}
doc <- NULL
doc$run.date <- date()
doc$version <- system(' git rev-parse HEAD', intern=TRUE)
doc$author <- "Steve Simon (KUMC)"
doc$maintainer <- "Steve Simon (KUMC)"
doc$assistants <- "no one just yet"
```

This program reads data from an i2b2 query and produces
simple analyses and graphs. It stores the data and some
intermediate files in an RData file.

This program was run on `r doc$date` using version `r doc$version`.
The original author is `r doc$author`. `r doc$maintainer`
is currently maintaining and enhancing this program
with the assistance of `r doc$assistants`.

```{r load-required-libraries, echo=TRUE}
library("ggplot2")
library("reshape")
library("RSQLite")
```

```{r set-options, echo=TRUE}

# Don't wrap so much
options(width=100)

```

Case-control
============
For context, see [485].

[485]: https://informatics.gpcnetwork.org/trac/Project/ticket/485
[bc_qa]: https://bitbucket.org/gpcnetwork/bc_qa

```{r review-table-size, echo=TRUE}

# use-this-database.txt should have one entry, the name of the database.

# for now, I am reading in every table, but as I get better acquainted, 
# I will only read in those tables that I really need

setwd("../bc_case_control")
db_name <- read.table(file="use_this_database.txt", stringsAsFactors=FALSE)[1, 1]
conn_site <- dbConnect(SQLite(), dbname=db_name)

sql_query <-NULL
db_tables <- NULL

sql_query[["concepts"]] <-
  "select concept_cd, name_char
   from concept_dimension"

sql_query[["cases"]] <-
  "select distinct patient_num, concept_cd
   from observation_fact
   where concept_cd ='SEER_SITE:26000'"   

sql_query[["controls"]] <-
  "select distinct patient_num, concept_cd
   from observation_fact
   where concept_cd LIKE ('SEER_SITE:220' || '_%')" 

sql_query[["facts"]] <-
  "select distinct f.patient_num, f.concept_cd from observation_fact f"   

sql_query[["count"]] <-
  "select concept_cd, count(1) AS 'concept_count'
   from observation_fact
   group by concept_cd"

for (i in names(sql_query)) {
  db_tables[[i]] <- dbGetQuery(conn_site, sql_query[[i]])
}
sapply(db_tables,dim)

case.patients <-    sort(unique(db_tables$cases$patient_num))
control.patients <- sort(unique(db_tables$controls$patient_num))
both.patients <-    intersect(case.patients, control.patients)                          
n.cases    <- length(case.patients)
n.controls <- length(control.patients)
n.both     <- length(both.patients)
```

There are `r n.cases` cases, as defined by the string(s), `r case_names`. The first
few patients in the case list are `r head(case.patients)`.

There are `r n.controls` controls, as defined by the string(s), `r control_names`. The first
few patients in the control list are `r head(control.patients)`.

There are `r n.both` patients who are in both the cases and the controls. We will remove these
from the data set before further analysis.


```{r merge-event-information, echo=TRUE}
# Again, this might be simpler and faster in SQL.

# Anything that is not a case name or control name is a predictor.
predictor.names <- setdiff(sort(unique(concepts$concept_cd)),c(case.names,control.names))
# get a count for each predictor.
tb <- table(tdf1$concept_cd)[predictor.names]
# remove any predictor that does not occur at least 5 times.
predictor.names <- names(tb[tb>5])
tdf6 <- data.frame(concept_cd=predictor.names)
tdf7 <- merge(tdf1, tdf6)
# use name_char, as it is more descriptive than concept_cd.
event_merge <- merge(tdf7, concepts[,c("concept_cd","name_char")])
tdf8 <- dcast(event_merge, patient_num ~ name_char, is.present)
dim(tdf8)
# Replace blanks and dashes with dots
simple.names <- predictor.names
for (x in c(" ","-") {
 simple.names <- gsub(x, ".", simple.names, fixed=TRUE)
}
# Remove other special characters
for (x in c("[", "]", "(", ")", ",")) {
 simple.names <- gsub(x, "", simple.names, fixed=TRUE)
}
names(tdf8)[-1] <- simple.names
```



```{r calculate-simple-tables, echo=TRUE}
print(predictor.variables)
tree.formula <- as.formula(paste("cc ~", paste(predictor.variables, collapse=" + ")))
print(tree.formula)
library("rpart")
tree.model <- rpart(tree.formula, data=pd)
summary(tree.model)
plot(tree.model)
text(tree.model)
model.variables <- names(tree.model$variable.importance)
for (v in model.variables) {
  ppv <- round(100 * sum((pd$cc=="Case")    & (pd[,v]==1)) / sum(pd[,v]==1))
  npv <- round(100 * sum((pd$cc=="Control") & (pd[,v]==0)) / sum(pd[,v]==0))
  ti <- paste(v,"\nppv = ",ppv,"%; npv = ",npv,"%",sep="")
  mosaicplot(table(pd[,v], pd$cc), dir=c("h","v"),main=ti)
}

```

```{r save-everything, echo=TRUE}
save.image(file="case_control.RData")
```