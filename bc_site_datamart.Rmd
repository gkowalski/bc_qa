# Breast Cancer - Site Datamart
```{r echo=FALSE}
# ============================================================================
###  Creates site-specific tumor-level datamart
# Input Dataframes
#   dataset       - desriptors for site's input dataset 
#   tumor.site    - pt tumors listing
#   survey.sample - complex frame created by bc_excl
# 
# Note - script was modeled after 'bc_random_smaple.rmd'
#
# 11-Sep Genesis
# 22-Sep SAVEPOINT (RMD file committed to TortoiseHg)
# 22-Sep Embed 'code.descriptor' (code and code.name) into column value, instead of just code
# 22-Sep De-couple 'AddVariable' and 'DescribeVariable'
# 22-Sep Handles different data types for code values (CHAR, DATE & NUM)
# 23-Sep Uses '||' as delimiter between code and code.name (for character data types)
# 24-Sep SAVEPOINT (RMD file committed to TortoiseHg)
# 24-Sep Moved datamart working directory to 'bc-datamart'
# 25-Sep Restructured error handling
# 25-Sep SAVEPOINT (RMD file committed to TortoiseHg) 
# 25-Sep Provide all encounters, eligible and ineligible for the study
# 25-Sep SAVEPOINT (RMD file committed to TortoiseHg)
# 25-Sep Calculate age at dx and provide as a gpc variable
# 02-Oct Uses 'v.col.terms' dataframe for search term values
# 02-Oct SAVEPOINT (RMD file committed to TortoiseHg)
# 05-Oct Uses 'v.col.terms' data typing to drive 'visualizations'
# 05-Oct SAVEPOINT (RMD file committed to TortoiseHg)
# 05-Oct Uses 'studyid-to-rownumber' mapping file
# 05-Oct SAVEPOINT (RMD file committed to TortoiseHg)
# 06-Oct Revised column order of final datamart (moving study id and row_number to the front)
# 05-Oct SAVEPOINT (RMD file committed to TortoiseHg)
# 13-Oct Reads data sources from bc-data-files directory
# 14-Oct Now filters for only 'consented' patients
# 15-Oct SAVEPOINT (RMD file committed to TortoiseHg)
# 15-Oct Output data files to deestination directory
# 28-Oct Handle birthdates that are NA (work-around for UIOWA)
# 30-Oct Re-fetch birthdates for NAs (aka UIOWA)
# 30-Oct SAVEPOINT (RMD file committed to TortoiseHg)
# 30-Oct Changed names of output files, making site the suffix
# 30-Oct SAVEPOINT (RMD file committed to TortoiseHg)
# 02-Nov Consolidated 'All-Site Consented' datamart
# 02-Nov SAVEPOINT (RMD file committed to TortoiseHg)
# 02-Nov Handle gpc.sex that are NA (work-around for UIOWA)
# 03-Nov Apply date-shift to consented patients
# 16-Nov Final packaging of 'All-Site, Consented' datamart
# 02-Nov SAVEPOINT (RMD file committed to TortoiseHg)
# 19-Nov Decoding of 13 variables (where concept_name is not available)
# 19-Nov SAVEPOINT (RMD file committed to TortoiseHg)
# 20-Nov Added 0670, 0820, 0830 to set of decoded columns (were only partially decoded)
# ============================================================================
```

### Package Set-Up and Initialization 

```{r Package Set-Up, include=FALSE}

# Include PHM function libraries
source('/d1/home/vleonardo/PHM-Development/PHM-LIBRARY.rmd')  # Loads PHM functions
# library(ggplot2)
library(reshape)
PHM.PackageSetup()

# Don't wrap so much
options(width=300)
opts_chunk$set(echo=FALSE)

# BC Function library
source('/d1/home/vleonardo/GPC-Development/bc_qa/bc_qa_txform.R')  
g.allsites.switch <<- FALSE
```

### Load Look-up Tables (Site Filenames & Variable-Names)

```{r Load Search Term Dictionary, include=FALSE}
v.site.files <- data.frame(site='KUMC', source.db='KUMC-16-kumcBC.db')
v.site.files <- rbind(v.site.files, data.frame(site='MCRF', source.db='MCRF-34-BC_Final_MCRF.db'))
v.site.files <- rbind(v.site.files, data.frame(site='MCW', source.db='MCW-31-gpc_breastcancer_export_3_3_2015.db'))
v.site.files <- rbind(v.site.files, data.frame(site='UIOWA', source.db='UIOWA-38-BRCA'))
v.site.files <- rbind(v.site.files, data.frame(site='UMN', source.db='UMN-30-UMN BC SQLLite v2 with seq num.db'))
v.site.files <- rbind(v.site.files, data.frame(site='UNMC', source.db='UNMC-37-UNMC_BCS_with560.db'))
#v.site.files <- rbind(v.site.files, data.frame(site='UTHSCSA', source.db='UTHSCSA-35-bc_560.db'))
v.site.files <- rbind(v.site.files, data.frame(site='UTSW', source.db='UTSW-32-bc_utsw20150304.db'))
v.site.files <- rbind(v.site.files, data.frame(site='WISC', source.db='WISC-21-gpcnetworkwisc_02_27_2.db'))

v.col.terms  <- data.frame(term.1='Breast', term.2='Breast', col.name='Seer.Site.Breast', col.data.type='CHAR')
v.col.terms <- rbind(v.col.terms, data.frame(term.1='0160', term.2='race 1', col.name='NAACCR.0160.Race.1', col.data.type='CHAR'))
v.col.terms <- rbind(v.col.terms, data.frame(term.1='0161', term.2='race 2', col.name='NAACCR.0161.Race.2', col.data.type='CHAR'))
v.col.terms <- rbind(v.col.terms, data.frame(term.1='0162', term.2='race 3', col.name='NAACCR.0162.Race.3', col.data.type='CHAR'))
v.col.terms <- rbind(v.col.terms, data.frame(term.1='0163', term.2='race 4', col.name='NAACCR.0163.Race.4', col.data.type='CHAR'))
v.col.terms <- rbind(v.col.terms, data.frame(term.1='0164', term.2='race 5', col.name='NAACCR.0164.Race.5', col.data.type='CHAR'))
v.col.terms <- rbind(v.col.terms, data.frame(term.1='0190', term.2='spanish', col.name='NAACCR.0190.Spanish', col.data.type='CHAR'))
v.col.terms <- rbind(v.col.terms, data.frame(term.1='0220', term.2='sex', col.name='NAACCR.0220.Sex', col.data.type='CHAR'))
v.col.terms <- rbind(v.col.terms, data.frame(term.1='0240', term.2='birth', col.name='NAACCR.0240.Birth.Date', col.data.type='DATE'))  # Date of birth
v.col.terms <- rbind(v.col.terms, data.frame(term.1='0380', term.2='central', col.name='NAACCR.0380.Seqno.Central', col.data.type='CHAR'))  # Seqno Central
v.col.terms <- rbind(v.col.terms, data.frame(term.1='0390', term.2='diagnosis', col.name='NAACCR.0390.Dx.Date', col.data.type='DATE'))  # Date of diagnosis
v.col.terms <- rbind(v.col.terms, data.frame(term.1='0400', term.2='primary', col.name='NAACCR.0400.Primary.Site', col.data.type='CHAR'))
v.col.terms <- rbind(v.col.terms, data.frame(term.1='0410', term.2='laterality', col.name='NAACCR.0410.Laterality', col.data.type='CHAR'))
v.col.terms <- rbind(v.col.terms, data.frame(term.1='0440', term.2='grade', col.name='NAACCR.0440.Grade', col.data.type='CHAR'))
v.col.terms <- rbind(v.col.terms, data.frame(term.1='0490', term.2='confirmation', col.name='NAACCR.0490.Confirmation', col.data.type='CHAR'))
v.col.terms <- rbind(v.col.terms, data.frame(term.1='0521', term.2='morph', col.name='NAACCR.0521.Morphology', col.data.type='CHAR'))
v.col.terms <- rbind(v.col.terms, data.frame(term.1='0560', term.2='hospital', col.name='NAACCR.0560.Seqno.Hosp', col.data.type='CHAR'))
v.col.terms <- rbind(v.col.terms, data.frame(term.1='0610', term.2='class', col.name='NAACCR.0610.Class.Case', col.data.type='CHAR'))
v.col.terms <- rbind(v.col.terms, data.frame(term.1='0670', term.2='surg', col.name='NAACCR.0670.Surg.Prim.Site', col.data.type='CHAR'))
v.col.terms <- rbind(v.col.terms, data.frame(term.1='0820', term.2='positive', col.name='NAACCR.0820.Reg.Nodes.Pos', col.data.type='CHAR'))  # Regional Nodes Positive
v.col.terms <- rbind(v.col.terms, data.frame(term.1='0830', term.2='examine', col.name='NAACCR.0830.Reg.Nodes.Examined', col.data.type='CHAR'))  # Regional Nodes Examined
v.col.terms <- rbind(v.col.terms, data.frame(term.1='1750', term.2='contact', col.name='NAACCR.1750.Last.Contact.Date', col.data.type='DATE'))  
v.col.terms <- rbind(v.col.terms, data.frame(term.1='1760', term.2='vital', col.name='NAACCR.1760.Vital.Status', col.data.type='CHAR'))
v.col.terms <- rbind(v.col.terms, data.frame(term.1='1860', term.2='recurrence', col.name='NAACCR.1860.Recurrence.Date', col.data.type='DATE'))
v.col.terms <- rbind(v.col.terms, data.frame(term.1='1861', term.2='flag', col.name='NAACCR.1861.Recurrence.Date.1st.Flag', col.data.type='CHAR'))
v.col.terms <- rbind(v.col.terms, data.frame(term.1='2850', term.2='dx', col.name='NAACCR.2850.CSMets.Dx', col.data.type='CHAR'))
v.col.terms <- rbind(v.col.terms, data.frame(term.1='2860', term.2='eval', col.name='NAACCR.2860.CSMets.Eval', col.data.type='CHAR'))
v.col.terms <- rbind(v.col.terms, data.frame(term.1='2869', term.2='factor', col.name='NAACCR.2869.HER2.CSSSF15', col.data.type='CHAR'))
v.col.terms <- rbind(v.col.terms, data.frame(term.1='2876', term.2='factor', col.name='NAACCR.2876.MS.Method.CSSSF22', col.data.type='CHAR'))
v.col.terms <- rbind(v.col.terms, data.frame(term.1='2877', term.2='factor', col.name='NAACCR.2877.MS.Result.CSSSF23', col.data.type='CHAR'))
v.col.terms <- rbind(v.col.terms, data.frame(term.1='2880', term.2='factor', col.name='NAACCR.2880.ER.CSSSF01', col.data.type='CHAR'))
v.col.terms <- rbind(v.col.terms, data.frame(term.1='2890', term.2='factor', col.name='NAACCR.2890.PR.CSSSF02', col.data.type='CHAR'))
v.col.terms <- rbind(v.col.terms, data.frame(term.1='2940', term.2='AJCC-6', col.name='NAACCR.2940.AJCC6.T', col.data.type='CHAR'))
v.col.terms <- rbind(v.col.terms, data.frame(term.1='3000', term.2='AJCC-6', col.name='NAACCR.3000.AJCC6.Stage', col.data.type='CHAR'))
v.col.terms <- rbind(v.col.terms, data.frame(term.1='3020', term.2='SS2000', col.name='NAACCR.3020.SS2000', col.data.type='CHAR'))
v.col.terms <- rbind(v.col.terms, data.frame(term.1='3400', term.2='AJCC-7', col.name='NAACCR.3400.AJCC7.T', col.data.type='CHAR'))
v.col.terms <- rbind(v.col.terms, data.frame(term.1='3430', term.2='AJCC-7', col.name='NAACCR.3430.AJCC7.Stage', col.data.type='CHAR'))
message("Number of search terms identified: ",nrow(v.col.terms))
```

```{r AddVariable - Add new column to aggregated datamart, based on search strings}
BCRup.AddVariableToDatamart <- function(p.datamart, p.site.variables, p.site.ptobs, 
                                        p.code.string.1, p.code.string.2, 
                                        p.new.col.name, p.code.data.type) {

  # NOTE: Search terms must be found in both 'variable name' and 'concept path'
  # NOTE: Ignores case and punctuation in the concept path  
  
  log.record <- list("")
  tmp.valid.terms.flag <- TRUE
  tmp.new.col.descriptor.name <- paste0(p.new.col.name,".Descriptor")  # Used for CHAR data types
  tmp.datamart <- p.datamart
  
  # Check for matching variable -----------------------------------------------------
  message("Checking variable to be added: ",p.new.col.name) 
  # Ensure only 1 variable matches search terms
  message("... searching variable names containing: '",
          p.code.string.1,"' & '",p.code.string.2,"'")
  tmp.var.found.cnt <- nrow(subset(p.site.variables, 
                          grepl(p.code.string.1,concept_path,ignore.case=TRUE) &
                          grepl(p.code.string.2,concept_path,ignore.case=TRUE) ))  
  message("Number of variables found matching search terms: ",tmp.var.found.cnt)
                          
  # Variable not found!
  if (tmp.var.found.cnt == 0) {
    log.msg <- "Unable to find a variable matching search terms."
    log.action.taken <- "WARNING: Variable values will be set to NA."
    log.record <- data.frame(p.new.col.name,p.code.string.1,p.code.string.2,
                                log.msg,log.action.taken)
    v.script.log <<- rbind(v.script.log, 
                          log.record) 
    tmp.valid.terms.flag <- FALSE
    } 
  
  # More than ONE variable found!
  if (tmp.var.found.cnt > 1) {
    log.msg <- "Collision where multiple variables found matching search strings."
    log.action.taken <- "WARNING: Values from multiple variables merged into one column."
    log.record <- data.frame(p.new.col.name,p.code.string.1,p.code.string.2,
                           log.msg,log.action.taken)
    v.script.log <<- rbind(v.script.log, 
                          log.record) 
    }
  
  # Search and load any matching observation facts -----------------------------------------------------  
  message("Checking patient data (observation facts) for populated concept codes: ",p.new.col.name) 
  message("... searching facts for concept paths containing: '",
          p.code.string.1,"' & '",p.code.string.2,"'") 
  tmp.new.col.facts <- subset(p.site.ptobs, 
                              grepl(p.code.string.1,code.path,ignore.case=TRUE) &
                              grepl(p.code.string.2,code.path,ignore.case=TRUE) )   
  tmp.new.col.facts <- unique(tmp.new.col.facts[,c("patient.num","encounter.num",
                                                   "code","code.name","nval","start.date.char")]) 
  tmp.ncf.cnt <- nrow(tmp.new.col.facts)  # Necessary for knitr markdown 
  message("... number of unique records found: ",tmp.ncf.cnt)
  message("... number of unique values founds: ",length(unique(tmp.new.col.facts$code)))
  
    
  # Check for matching observation facts -----------------------------------------------------  
  if (tmp.valid.terms.flag) {
    if (! (p.code.data.type %in% c("CHAR","NUM","DATE"))) {
      log.msg <- "Datatype specified is not supported."
      log.action.taken <- "WARNING: Using simple code values for column."
      log.record <- data.frame(p.new.col.name,p.code.string.1,p.code.string.2,
                                  log.msg,log.action.taken)
      v.script.log <<- rbind(,v.script.log,log.record)
      }
    
    if (tmp.ncf.cnt > nrow(p.datamart)) {
        message("... verifying cardinality of result set for variable requested.")
        log.msg <- "Cardinality of variable does not correspond with desired result set."
        log.action.taken <- "WARNING: First value has arbitrarily been selected."
        log.record <- data.frame(p.new.col.name,p.code.string.1,p.code.string.2,
                                     log.msg,log.action.taken)
        v.script.log <<- rbind(v.script.log, 
                               log.record) 
            
        tmp.new.col.facts <- aggregate(tmp.new.col.facts,
                                    by=list(tmp.new.col.facts$encounter.num),
                                    FUN=head,1)
                
        tmp.valid.terms.flag <- TRUE
    } else {
      # Ensure observation facts exist for search terms
      message("ncf: ",tmp.ncf.cnt)
      if (tmp.ncf.cnt == 0) {
        log.msg <- "Unable to locate any facts for search strings in concept paths."
        log.action.taken <- "WARNING: Variable values will be set to NA."
        log.record <- data.frame(p.new.col.name,p.code.string.1,p.code.string.2,
                                     log.msg,log.action.taken)
        v.script.log <<- rbind(v.script.log, 
                               log.record) 
        tmp.valid.terms.flag <- FALSE
      }
    }
  }

  #------------------------------------------------------------------------------------
  # All conditions handled, proceed w/ adding variable values to datamart 
  # -- Invalid terms will have NAs loaded
  #-----------------------------------------------------------------------------------
  if (tmp.valid.terms.flag) {
    # Handle based on data type
    if (p.code.data.type == "NUM") {
      tmp.new.col.facts <- tmp.new.col.facts[,c("patient.num","encounter.num","nval")]
      tmp.new.col.facts <- setNames(tmp.new.col.facts,c("patient.num","encounter.num",
                                                      p.new.col.name))
    } else {
      if (p.code.data.type == "DATE") {
        # Use start.date.char to get hh:mm:ss
        tmp.new.col.facts <- tmp.new.col.facts[,c("patient.num","encounter.num","start.date.char")]
        tmp.new.col.facts <- setNames(tmp.new.col.facts,c("patient.num","encounter.num",
                                                      p.new.col.name))
      } else {
        if (!(p.code.data.type %in% c("NUM","DATE"))) {  # Handle as CHAR, includes unsupported data types
          message("... handling as type CHAR")
          tmp.new.col.facts <- tmp.new.col.facts[,c("patient.num","encounter.num","code","code.name")]
          tmp.new.col.facts <- setNames(tmp.new.col.facts,c("patient.num","encounter.num",
                                                      p.new.col.name,tmp.new.col.descriptor.name))
        } 
      }    
    }
    tmp.new.col.facts <- unique(tmp.new.col.facts)
    tmp.datamart <- merge(tmp.datamart, tmp.new.col.facts,
                          all.x=TRUE)  # don't prune on join mis-matches         
    log.msg <- "Search terms found."
    log.action.taken <- "Successfully added new column!"
    log.record <- data.frame(p.new.col.name,p.code.string.1,p.code.string.2,
                                 log.msg,log.action.taken)
    message(log.action.taken)
    v.script.log <<- rbind(v.script.log, 
                           log.record)  # Assign value to global variable
  } else { # Terms are not valid, so simply return NAs instead
    message("... assigning NAs to invalid term for variable: ",p.new.col.name)
    tmp.datamart[,c(p.new.col.name)] <- NA
    if (!(p.code.data.type %in% c("NUM","DATE"))) {  # Handle as CHAR, includes unsupported data types
      tmp.datamart[,c(tmp.new.col.descriptor.name)] <- NA
      }
  }
  return(tmp.datamart)
}
```

```{r DescribeDatamartColumn - Generate frequency and distribution charts}
# Note - ignores case and punctuation n the concept path
BCRup.DescribeDatamartColumn <- function(p.datamart,p.col.name) {
 
     # By-pass descriptor columns, as they are merged w/ their root values
     if (grepl(".Descriptor$",p.col.name)) {
       return("Skipping over 'descriptor' column")
     }
     
     # Default data type
     p.col.datatype <- "CHAR"
               
     # Check for NAs
     tmp.col.found.flag <- (nrow(p.datamart[! is.na(p.datamart[,p.col.name] ), ]) > 0)
     if  (! tmp.col.found.flag) {
       message("No 'Descriptive Analysis', as only NAs are present for column: ",tmp.col.name) 
       return("No 'Descriptive Analysis' performed")
       }
     
     # Handle GPC eligibility variables by determining data type
     if (grepl("^gpc.",p.col.name)) {
       if (grepl(".date.",p.col.name)) {
          p.col.datatype <- "DATE"
          } else {
            if (grepl(".dx.age$",p.col.name)) {
              p.col.datatype <- "NUM"
            }
          }
     } else { # Handle as NAACCR variable
       p.col.datatype <- v.col.terms$col.data.type[v.col.terms$col.name==p.col.name]
     }
  
    # Convert dates from character to date format
    if (p.col.datatype == "DATE") { 
       p.datamart[,p.col.name] <- as.POSIXct(p.datamart[,p.col.name],"%y-%m-%d %T")
       } 
    
    if ((p.col.datatype == "DATE") | (p.col.datatype == "NUM")) {
       print(summary(p.datamart[,p.col.name]))
    } else {# Handle as character
       # Descriptive analysis for variable added
       tmp.next.col <- which(colnames(p.datamart)==p.col.name) + 1
       p.datamart$col.expanded <- p.datamart[,p.col.name]
       # Add descriptor, if not a GPC Eligibility variable
       if (! grepl("^gpc.",p.col.name)) {
         p.datamart$col.expanded <- paste0(p.datamart[,p.col.name]," :: ",p.datamart[,tmp.next.col])
         }
       tmp.frequency.table <- as.data.frame(addmargins(table(p.datamart$col.expanded)))
       tmp.frequency.table <- tmp.frequency.table[,c("Freq","Var1")]  # Switch column order
       colnames(tmp.frequency.table)[colnames(tmp.frequency.table)=="Var1"] <- tmp.col.name
       colnames(tmp.frequency.table)[colnames(tmp.frequency.table)=="Freq"] <- "Enctrs"
  
       print(tmp.frequency.table, right=FALSE)  
       }
   
}
```

```{r VisualizeDatamartColumn - Generate frequency and distribution charts}
# Note - ignores case and punctuation n the concept path /
BCRup.VisualizeDatamartColumn <- function(p.datamart,p.col.name) {
 
     # By-pass descriptor columns, as they are merged w/ their root values
     if (grepl(".Descriptor$",p.col.name)) {
       return("Skipping over 'descriptor' column")
     }
  
     tmp.col.found.flag <- (nrow(p.datamart[! (is.na(p.datamart[,p.col.name])),]) > 0)
     if  (! tmp.col.found.flag) {
       message("No 'Visual Analysis', as only NAs are present for column: ",p.col.name) 
       return("No 'Visual Analysis' performed")
       }

     # Remove any NAs from consideration (as they break the charts)
     p.datamart <- p.datamart[! (is.na(p.datamart[,p.col.name])),]
     
     p.col.datatype <- "CHAR"  # Default
     # Handle GPC eligibility variables by determining data type
     if (grepl("^gpc.",p.col.name)) {
       if (grepl(".date.",p.col.name)) {
          p.col.datatype <- "DATE"
          } else {
            if (grepl(".dx.age$",p.col.name)) {
              p.col.datatype <- "NUM"
            }
          }
     } else { # Handle as NAACCR variable
       p.col.datatype <- v.col.terms$col.data.type[v.col.terms$col.name==p.col.name]
     }          
     
    # Convert dates from character to date format
    if (p.col.datatype == "DATE") { 
       p.datamart[,p.col.name] <- as.POSIXct(p.datamart[,p.col.name],"%y-%m-%d %T")
       } 
    
    if (p.col.datatype == "DATE") {
       hist(p.datamart[,p.col.name],
            breaks="weeks", format="%b %y",
            freq=TRUE,
            main=p.col.name,
            col=c("lightsteelblue"),
            xlab="")
    } else {
      if (p.col.datatype == "NUM") {
         hist(p.datamart[,p.col.name],
              breaks=max(p.datamart[,p.col.name]),
              freq=TRUE,
              main=p.col.name,
              col=c("lightsteelblue"),
              xlab="")
      } else {# Handle as character
        tmp.frequency.table <- as.data.frame(addmargins(table(p.datamart[,p.col.name])))
        tmp.frequency.table <- tmp.frequency.table[,c("Freq","Var1")]
        colnames(tmp.frequency.table)[colnames(tmp.frequency.table)=="Var1"] <- p.col.name
        colnames(tmp.frequency.table)[colnames(tmp.frequency.table)=="Freq"] <- "Enctrs"
           
        # Charts
        pie(table(p.datamart[,p.col.name]),
            main=p.col.name)  
       
        p.datamart$col.expanded <- p.datamart[,p.col.name]
        # Add descriptor, if not a GPC Eligibility variable
        if (! grepl("^gpc.",p.col.name)) {
          tmp.next.col <- which(colnames(p.datamart)==p.col.name) + 1
          p.datamart$col.expanded <- paste0(p.datamart[,p.col.name]," :: ",p.datamart[,tmp.next.col])
          }
       
        tmp.frequency.table2 <- aggregate(p.datamart$encounter.num, 
                                          by=list(p.datamart$col.expanded), 
                                         function(x) length(unique(x)))
       
        tmp.frequency.table2 <- tmp.frequency.table2[order(tmp.frequency.table2$x,decreasing=TRUE),]
        tmp.row.cnt <- nrow(tmp.frequency.table2)
        tmp.max.analysis.cnt <- min(7,tmp.row.cnt)
        tmp.chart.subtitle <- "All Occurrences"
        if (tmp.row.cnt > tmp.max.analysis.cnt) {
            tmp.chart.subtitle <- paste0("Most Frequent Occurrences (Top ",tmp.max.analysis.cnt," of ",tmp.row.cnt,")")
        }
        tmp.frequency.table2 <- tmp.frequency.table2[1:tmp.max.analysis.cnt,]  
        op <- par(mar=c(5,4,3,2),bg="white")   # Bottom, left, top, right
        bp <- barplot(tmp.frequency.table2$x,
                       horiz=TRUE,
                       xlim=c(0,max(tmp.frequency.table2$x)*1.25),
                       col=c("lightsteelblue"),
                       #width allows all x labels to be shown
                       xlab="Encounters (Tumors)")         
        text(bp, x=0, labels=tmp.frequency.table2$Group.1, pos=4, cex=.85)
        mtext(side=3, line=1, p.col.name, font=2)
        mtext(side=3, line=0, tmp.chart.subtitle) 
        par(op)  # reset
        }
  }
}
```

### Loading 'dataset' object

```{r}
#input <- source('dataset.R')$value

# conn.site <- input$conn

# about has $record_id $site name, $bc_db filename, $content_length, submitter $name, $issues_other
# dataset <- input$about

v.output.dir <- '/d1/home/vleonardo/GPC-Development/bc-data-files/Phase1-DatamartOutput/'
v.site <- "KUMC"
dataset <- list("")
dataset$site <- v.site
#dataset$bc_db <- "KUMC-16-kumcBC"
#dataset$bc_db <- "UMN-30-UMN BC SQLLite v2 with seq num"
dataset$bc_db <- v.site.files[v.site.files$site==v.site,"source.db"]

message('Dataset identified: ',dataset$bc_db)
conn.site <- dbConnect(SQLite(),paste0('/d1/home/vleonardo/GPC-Development/bc-data-files/Phase1-SourceDbs/',dataset$bc_db) )
print(dbListTables(conn.site))

# builder.summary reads raw db
# Note - this is not used for the concept terms, rather 'code paths' from the concept dimension is what is used.
bs <- (builder.summary(conn.site)[, c('variable', 'pat_qty', 'enc_qty', 'fact_qty')])
print(bs)

# Load site's variable and concept codes directly from db file
site <- list("")
site$variables <- dbGetQuery(conn.site,"select * from variable")
print(site$variables[,c("concept_path","name_char")])
site$concept.codes <- dbGetQuery(conn.site,"select * from concept_dimension")

# Diagnostics for site's data
message('SQLITE db file) patient_dimension: ',
        dbGetQuery(conn.site,"select count(*) from patient_dimension"))
message('SQLITE db file) variable: ',
        dbGetQuery(conn.site,"select count(*) from variable"))
message('SQLITE db file) concept_dimension: ',
        dbGetQuery(conn.site,"select count(*) from concept_dimension"))
message('SQLITE db file) observation_fact: ',
        dbGetQuery(conn.site,"select count(*) from observation_fact"))

```

### Load and Merge Observations With Concept Descriptors

``` {r}
############################################################################
# Delaware: n=4660583
# Expected Run-time: 6.5 mins
site$ptobs <- PHM.LoadObservationsWithConceptDescriptors(conn.site)

#saveRDS(site$ptobs,  paste0(v.output.dir,"BCDatamart-PtObs-",dataset$site,".rds"))
print(nrow(site$ptobs))
site$ptobs.code.paths <- unique(site$ptobs$code.path)                           
```

### Loading original patient data for `r dataset$site`
 -- variables used in QA process (exclusion criteria and receptor status)

```{r}
load("/d1/home/vleonardo/GPC-Development/bc_qa/bc_terms_results.RData")
message('Number of terms loaded: ',nrow(bcterm$term204))

tumor.site <- bc.exclusions(conn.site)   

print(names(tumor.site))
saveRDS(tumor.site,  paste0(v.output.dir,dataset$bc_db,"-",Sys.Date(),"-tumor-site.rds"))
x.tumor.site <- tumor.site  # Holding area for restoration/debugging purposes
#tumor.site <- readRDS(paste0(dataset$bc_db,"-",Sys.Date(),"-tumor-site.rds"))
message('Number of tumors loaded: ',(nrow(tumor.site)))
message('Number of pts in dataset: ',length(unique(tumor.site$patient_num)))


survey.sample <- check.cases(tumor.site)  # Creates tumor-level criteria flags
survey.sample$all.criteria <- reduce.logical(survey.sample)
message('Number of pts meeting inclusion criteria: ', 
        nrow(survey.sample[survey.sample$all.criteria,]))

survey.sample.summary <- count.cases(survey.sample)  # Produce table of criteria counts
print(survey.sample.summary)
```

### Fetch birth_date and sex for any patients w/o value

```{r}
# Note - tumor.site can have NAs for some birth_dates (possibly ineligible encounters)
if (nrow(subset(tumor.site,is.na(date.birth))) > 0) {
  nrow(subset(tumor.site,is.na(date.birth)))
  tmp.patient <- dbGetQuery(conn.site,"select patient_num, birth_date, sex_cd from patient_dimension")
  tumor.site <- merge(tumor.site,tmp.patient)
  tumor.site$date.birth <- tumor.site$birth_date
  tumor.site$sex <- tumor.site$sex_cd
  nrow(subset(tumor.site,is.na(date.birth)))
}
```

### Filter for only eligible encounters(tumors)
```{r}
# Remove original receptor status variables f/ inclusion set, as they are replicated in NAACCR vars
q.site.datamart <- subset(tumor.site,select=-c(er.csf.1,pr.csf.2,her2.csf.15,mgs.method.csf.22,mgs.score.csf.23))
colnames(q.site.datamart)[colnames(q.site.datamart)=="patient_num"] <- "patient.num"
colnames(q.site.datamart)[colnames(q.site.datamart)=="encounter_num"] <- "encounter.num"

# Add prefix to survey variables to distinguish them from TR & EHR direct-sourced items
for (i in 3:ncol(q.site.datamart)) {
  tmp.col.name <- names(q.site.datamart[i])
  colnames(q.site.datamart)[colnames(q.site.datamart)==tmp.col.name] <- paste0("gpc.",tmp.col.name)
}

# Add GPC Site Identifier
q.site.datamart <- cbind(gpc.site.name=dataset$site,q.site.datamart)

# Work-around for UIOWA) GPC.date.birth is NA for some pts, but sqldb has value in patient dimension

# Calculate age at diagnosis
tmp.dx <- list("")
tmp.dx <- q.site.datamart[,c("encounter.num","gpc.date.dx","gpc.date.birth")]
tmp.dx$age <-   
  as.POSIXlt(tmp.dx$gpc.date.dx)$year - 
  as.POSIXlt(tmp.dx$gpc.date.birth)$year
tmp.dx$dx.mmdd <- (as.POSIXlt(tmp.dx$gpc.date.dx)$mon*100) +
                             as.POSIXlt(tmp.dx$gpc.date.dx)$mday 
tmp.dx$birth.mmdd <- (as.POSIXlt(tmp.dx$gpc.date.birth)$mon*100) +
                             as.POSIXlt(tmp.dx$gpc.date.birth)$mday 
tmp.dx$age[!(is.na(tmp.dx$gpc.date.birth)) & (tmp.dx$dx.mmdd < tmp.dx$birth.mmdd)] <- 
  tmp.dx$age - 1
q.site.datamart$gpc.dx.age <- tmp.dx$age[tmp.dx$encounter.num==q.site.datamart$encounter.num]
# Move column towards beginning of list
q.site.datamart <- q.site.datamart[,c(1,2,3,ncol(q.site.datamart),5:ncol(q.site.datamart)-1)]

# Add eligiblity flag
q.site.datamart <- merge(q.site.datamart,survey.sample[,c("patient_num","encounter_num","all.criteria")],
                         by.x=c("patient.num","encounter.num"),
                         by.y=c("patient_num","encounter_num"))
colnames(q.site.datamart)[colnames(q.site.datamart)=="all.criteria"] <- "gpc.enctr.eligible"

message("Total number of patients submitted: ", length(unique(q.site.datamart$patient.num)))
message("Total number of encounters submitted: ", length(unique(q.site.datamart$encounter.num)))
message("Number of eligible patients: ", length(unique(q.site.datamart$patient.num[q.site.datamart$gpc.enctr.eligible])))
message("Number of eligible encounters(tumors): ", nrow(q.site.datamart[q.site.datamart$gpc.enctr.eligible,]))
```

### Trim master patient observations for only eligible encounters, solely for performance reasons

```{r}
site$ptobs <- subset(site$ptobs, encounter.num %in% q.site.datamart$encounter.num)
print(nrow(site$ptobs))
```


### Add next variables, specifying 2 search terms for 'variable name'

```{r}
# Variable Initialization
v.script.log <- data.frame(p.new.col.name=NA,p.code.string.1=NA,p.code.string.2=NA,log.msg=NA,log.action.taken=NA)
message("Rows in tumor.site: ", nrow(tumor.site))
tmp.tumor.site <- q.site.datamart

# Add each variable
for (r in 1:nrow(v.col.terms)) {
  tmp.col.name <- as.character(v.col.terms$col.name[r])
  tmp.tumor.site <- BCRup.AddVariableToDatamart(tmp.tumor.site, 
                                                site$variables,
                                                site$ptobs, 
                                                v.col.terms$term.1[r],
                                                v.col.terms$term.2[r],
                                                tmp.col.name, 
                                                v.col.terms$col.data.type[r]) 
}
q.site.datamart <- tmp.tumor.site
v.script.log <- v.script.log[! (is.na(v.script.log$p.new.col.name)),]
```

###  Summary of Variables Loaded and Actions Taken

```{r Variable Summary Report} 
names(q.site.datamart)
message("Rows in tumor.site: ", nrow(q.site.datamart))
print(v.script.log)
```

### Problems Encountered: `r nrow(v.script.log[!grepl("Success",v.script.log$log.action.taken),])`

```{r Error Log} 
message("Flagged Issues w/ Variables")
print(v.script.log[!grepl("Success",v.script.log$log.action.taken),])
```

### Descriptive Analysis

```{r Descriptive Analysis} 
for (tmp.col.index in 4:(ncol(q.site.datamart))) # Skip P#, E# and Site columns
  {  
  tmp.col.name <- names(q.site.datamart[tmp.col.index])                         
  BCRup.VisualizeDatamartColumn(q.site.datamart,tmp.col.name)
  BCRup.DescribeDatamartColumn(q.site.datamart, tmp.col.name)    
  }

# Provides a presentation similar to a standard 'Table One' 
for (tmp.col.index in 4:(ncol(q.site.datamart))) # Skip P#, E# and Site columns
  {  
  tmp.col.name <- names(q.site.datamart[tmp.col.index])
  BCRup.DescribeDatamartColumn(q.site.datamart, tmp.col.name)  
  }
```

### Export Encounters => Datamart

```{r Export Datamart}
message('Output directory: ',getwd())
v.filename <- paste0(v.output.dir,"BCDatamart-AllPts-AllEnctrs-",dataset$site,".csv")
write.csv(q.site.datamart, file = v.filename, row.names=FALSE)
message('Number of rows written: ',nrow(q.site.datamart))

v.filename <- paste0(v.output.dir,"BCDatamart-IssuesLog-",dataset$site,".csv")
write.csv(v.script.log[!grepl("Success",v.script.log$log.action.taken),], file = v.filename, row.names=FALSE)
message('Number of issues written: ',nrow(v.script.log[!grepl("Success",v.script.log$log.action.taken),]))
```

### Datamart Description: `r dataset$site`

```{r Datamart Description, echo=FALSE}
# use of 'print' in markdown creates a new bordered block in the output
print("Column Stats: gpc.stage.ss")
print(as.data.frame(table(q.site.datamart$gpc.stage.ss)))

print("Column Stats: NAACCR.0440.Grade.Descriptor")
print(as.data.frame(table(q.site.datamart$NAACCR.0440.Grade.Descriptor)))

message('Problems encountered:  ',nrow(v.script.log[!grepl("Success",v.script.log$log.action.taken),]))
print(paste0(Sys.time()))
v.script.log[!grepl("Success",v.script.log$log.action.taken),]
```

### Datamart Summary Statistics (ALL PATIENTS): `r dataset$site`

```{r Datamart Summary Statistics - All Patients (Before), echo=FALSE}
message('GPC Site:                ', dataset$site)
message('Patients loaded:         ',length(unique(q.site.datamart$patient.num)))
message('Encounters exported:     ',nrow(q.site.datamart),' (num of rows written)')
message('Pts/Encounters eligible: ',length(q.site.datamart$gpc.enctr.eligible[q.site.datamart$gpc.enctr.eligible]))
message('Dx Age (Mean):           ',mean(unique(q.site.datamart[,c("patient.num","gpc.dx.age")])$gpc.dx.age))
message('GPC Birth Date (Min):    ',min(q.site.datamart$gpc.date.birth))
message('NAACCR Birth Date (Min): ',min(q.site.datamart$NAACCR.0240.Birth.Date))
message('GPC Birth Date (Max):    ',max(q.site.datamart$gpc.date.birth))
message('NAACCR Birth Date (Max): ',max(q.site.datamart$NAACCR.0240.Birth.Date))
message('GPC Dx Date (Min):       ',min(q.site.datamart$gpc.date.dx))
message('NAACCR Dx Date (Min):    ',min(q.site.datamart$NAACCR.0390.Dx.Date))
message('GPC Dx Date (Max):       ',max(q.site.datamart$gpc.date.dx))
message('NAACCR Dx Date (Max):    ',max(q.site.datamart$NAACCR.0390.Dx.Date))
```

### Merge for Consented Study Ids Only

```{r Filter for Consented Study IDs, eval=FALSE}
BCRup.GetConsentedPtData <- function(p.site) {
# Iowa: 100101 - 100360
# KUMC: 150101 - 150360
# UWISC: 200101 - 200360
# UTSW: 250101 - 250360
# MCW: 300101 - 300360
# UNMC: 350101 - 350360
# UMN: 400101 - 400360
# MCRF: 450101 - 450360
  
# Load site's allpt-allenctr datamart
v.filename <- paste0(v.output.dir,"BCDatamart-AllPts-AllEnctrs-",p.site,".csv")
message("Reading 'all-pt all enctr' datamart: ",v.filename)
tmp.site.allpt.datamart <- read.csv(v.filename)
message("... ",nrow(tmp.site.allpt.datamart)," rows read.")

# Load site mapping file of consented study_ids to order_ids to patient_nums
# || PATIENT_NUM|| ORDER_ID || STUDY_ID  || DATE_SHIFT ||
v.study.mappings.dir <- '/d1/home/vleonardo/GPC-Development/bc-data-files/Phase1-StudyIdMappings/'
v.site.consented.mapping <- read.csv(paste0(v.study.mappings.dir,p.site,"-patient-mapping.csv"))
v.site.consented.mapping <- setnames(v.site.consented.mapping,
                       old=c("patient_num","order_id","study_id","date_shift"),
                       new=c("patient.num","gpc.order.id","gpc.study.id","gpc.date.shift"))
nrow(v.site.consented.mapping)

# Filter site datamart for consented pts
tmp.sdpc <- merge(tmp.site.allpt.datamart,
                  v.site.consented.mapping,
                  by.x="patient.num",
                  by.y="patient.num")
length(unique(tmp.sdpc$patient.num))

# Move Study id and Date Shift to front of the pack
tmp.sdpc <- tmp.sdpc[,c(3,ncol(tmp.sdpc)-1,ncol(tmp.sdpc)-2,1,2,ncol(tmp.sdpc),4:(ncol(tmp.sdpc)-3))]

# Apply date shift
tmp.sdpc$gpc.date.shift <- abs(tmp.sdpc$gpc.date.shift)
tmp.sdpc$gpc.date.birth <- as.Date(tmp.sdpc$gpc.date.birth) + tmp.sdpc$gpc.date.shift
message("... applying date shift for gpc.date.birth")
tmp.sdpc$gpc.date.dx    <- as.Date(tmp.sdpc$gpc.date.dx) + tmp.sdpc$gpc.date.shift
message("... applying date shift for gpc.date.dx")
tmp.sdpc <- setnames(tmp.sdpc,
                     old=c("gpc.date.birth","gpc.date.dx"),
                     new=c("gpc.date.birth.actl","gpc.date.dx.actl"))
for (i in v.col.terms$col.name[v.col.terms$col.data.type=="DATE"]) {
  message("... applying date shift for ",i)
  tmp.sdpc[,i] <- as.Date(tmp.sdpc[,i]) + tmp.sdpc[,"gpc.date.shift"]
  tmp.sdpc <- setnames(tmp.sdpc,
                       old=i,
                       new=paste0(i,".Actl"))  
}

tmp.site.consented.datamart <- tmp.sdpc
length(unique(tmp.site.consented.datamart$patient.num))
return(tmp.site.consented.datamart)
}
```

### STAGE 2 - BUILD SITE-SPECIFIC CONSENTED DATAMARTS (ONE AT A TIME)

```{r Build site-specific consented datamarts -- One at a time}
if (g.allsites.switch) {

v.output.dir <- '/d1/home/vleonardo/GPC-Development/bc-data-files/Phase1-DatamartOutput/'  
#v.sites <- c('KUMC','MCRF','MCW','UIOWA','UMN','UNMC','UTSW','WISC')
v.sites <- c('UMN')
v.site.consented.datamart <- BCRup.GetConsentedPtData(v.sites[1])

# Final packaging for output
v.site.consented.datamart$gpc.sex_cd <- NULL
v.site.consented.datamart$gpc.birth_date <- NULL
v.site.consented.datamart <- v.site.consented.datamart[order(
  v.site.consented.datamart$gpc.study.id,
                                                                     v.site.consented.datamart$encounter.num),]
v.filename <- paste0(v.output.dir,"BCDatamart-Site-Consented-",v.sites[1],".csv")
write.csv(v.site.consented.datamart, file = v.filename, row.names=FALSE)
message('Number of pts consented: ',length(unique(v.site.consented.datamart$patient.num)))
message('Number of rows written: ',nrow(v.site.consented.datamart))

}

```

### STAGE 3 - ALL-SITE DATAMART, CONSOLIDATE 

```{r Consolidate and filter for consented study ids}
if (g.allsites.switch) {

v.output.dir <- '/d1/home/vleonardo/GPC-Development/bc-data-files/Phase1-DatamartOutput/'  
#v.sites <- c('KUMC','MCRF','MCW','UIOWA','UMN','UNMC','UTSW','WISC')
v.sites <- c('KUMC','MCRF','UIOWA','UMN')
v.filename <- paste0(v.output.dir,"BCDatamart-Site-Consented-",v.sites[1],".csv")
v.consented.datamart <- read.csv(v.filename,stringsAsFactors=FALSE)
message("... Rows added for ",v.sites[1])
for (i in v.sites[2:length(v.sites)]) {
  v.filename <- paste0(v.output.dir,"BCDatamart-Site-Consented-",i,".csv")
  tmp.site.consented.datamart <- read.csv(v.filename) 
  v.consented.datamart <- rbind(v.consented.datamart,tmp.site.consented.datamart)
  message("... Rows added for ",i)
}
message(' ')
print(setNames(aggregate(cbind(patient.num,encounter.num)~gpc.site.name,
                data=v.consented.datamart,
                function(x) length(unique(x))),
          c("GPC Site","Patients","Enctr(Tumors)")))

# Export 'All-Site Consented' datamart
v.consented.datamart <- v.consented.datamart[
  order(v.consented.datamart$gpc.site.name,
        v.consented.datamart$gpc.study.id,
        v.consented.datamart$encounter.num),]
v.filename <- paste0(v.output.dir,"BCDatamart-ALLSITE-CONSENTED.csv")
write.csv(v.consented.datamart, file = v.filename, row.names=FALSE)
message(' ')
message('Total rows written: ',
        nrow(v.consented.datamart), " enctrs/tumors  ",
        length(unique(v.consented.datamart$patient.num))," pts")

}

```

### STAGE 4 - APPLY STANDARDIZED DECODING FOR SELECTED COLUMNS (Columns where sites did not provide code names)
```{r Decoding for select columns}
if (g.allsites.switch) {
v.codebook <- read.csv("/d1/home/vleonardo/GPC-Development/bc-datamart/i2b2 codebook-decoded-subset.csv",stringsAsFactors=FALSE)
v.naaccr.code.list <- c('0610','0670','0820','0830','2850','2860','2869','2876','2877','2880','2890','2940','3000','3020','3400','3430')
v.consented.datamart <- read.csv("/d1/home/vleonardo/GPC-Development/bc-data-files/Phase1-DatamartOutput/BCDatamart-ALLSITE-CONSENTED.csv",stringsAsFactors=FALSE)
for (i.naaccr in v.naaccr.code.list) { 
  tmp.col.name <- as.character(v.col.terms$col.name[grepl(i.naaccr,v.col.terms$col.name)])
  message('... decoding: ',i.naaccr,'-',tmp.col.name)
  tmp.col.descriptor <- paste0(v.col.terms$col.name[grepl(i.naaccr,v.col.terms$col.name)],'.Descriptor')
  v.consented.datamart$code_value <- as.character(v.consented.datamart[,tmp.col.name])
#  v.consented.datamart$label <- unique(v.codebook$label[v.codebook$code_value==v.consented.datamart$code_value])
  v.consented.datamart <- merge(v.consented.datamart,v.codebook[,c("code_value","label")],
        by.x=c("code_value"), by.y=c("code_value"),all.x=TRUE)
  v.consented.datamart[,tmp.col.descriptor] <- v.consented.datamart$label
  v.consented.datamart$code_value <- NULL
  v.consented.datamart$label <- NULL

}

# Export 'All-Site Consented' datamart
v.consented.datamart <- v.consented.datamart[with(v.consented.datamart,order(gpc.site.name,gpc.study.id, encounter.num)),]
v.filename <- paste0(v.output.dir,"BCDatamart-ALLSITE-CONSENTED-DECODED.csv")
write.csv(v.consented.datamart, file = v.filename, row.names=FALSE)
message('Number of rows written: ',nrow(v.consented.datamart))

}
```

### Datamart Summary Statistics (ALL PATIENTS): `r dataset$site`

```{r Datamart Summary Statistics - All Patients, echo=FALSE}
if (g.allsites.switch) {
message('ALL-SITE DATAMART (Consented Pts Only)')
message('Patients loaded:         ',length(unique(v.consented.datamart$patient.num)))
message('Encounters exported:     ',nrow(v.consented.datamart),' (num of rows written)')
message('Pts/Encounters eligible: ',length(v.consented.datamart$gpc.enctr.eligible[v.consented.datamart$gpc.enctr.eligible]))
message('Dx Age (Mean):           ',mean(unique(v.consented.datamart[,c("patient.num","gpc.dx.age")])$gpc.dx.age))
message('GPC Birth Date (Min):    ',min(v.consented.datamart$gpc.date.birth.actl))
message('NAACCR Birth Date (Min): ',min(v.consented.datamart$NAACCR.0240.Birth.Date))
message('GPC Birth Date (Max):    ',max(v.consented.datamart$gpc.date.birth))
message('NAACCR Birth Date (Max): ',max(v.consented.datamart$NAACCR.0240.Birth.Date))
message('GPC Dx Date (Min):       ',min(v.consented.datamart$gpc.date.dx))
message('NAACCR Dx Date (Min):    ',min(v.consented.datamart$NAACCR.0390.Dx.Date))
message('GPC Dx Date (Max):       ',max(v.consented.datamart$gpc.date.dx))
message('NAACCR Dx Date (Max):    ',max(v.consented.datamart$NAACCR.0390.Dx.Date))
}
```


### Datamart Summary Statistics (Consented Pts Only): `r dataset$site`

```{r Datamart Summary Statistics - Consented, echo=FALSE, eval=FALSE}
if (g.allsites.switch) {

# Descriptive Analysis} 
for (tmp.col.index in 4:(ncol(v.consented.datamart))) # Skip P#, E# and Site columns
  {  
  tmp.col.name <- names(v.consented.datamart[tmp.col.index])                         
  BCRup.VisualizeDatamartColumn(v.consented.datamart,tmp.col.name)
  BCRup.DescribeDatamartColumn(v.consented.datamart, tmp.col.name)    
  }

# Provides a presentation similar to a standard 'Table One' 
for (tmp.col.index in 4:(ncol(v.consented.datamart))) # Skip P#, E# and Site columns
  {  
  tmp.col.name <- names(v.consented.datamart[tmp.col.index])
  BCRup.DescribeDatamartColumn(v.consented.datamart, tmp.col.name)  
  }
}
```

